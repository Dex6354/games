<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üêç Cobrinha 2P (Firestore) - Otimizado</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .dpad-grid {
            display: grid;
            grid-template-areas: ". up ."
                                 "left center right"
                                 ". down .";
            grid-template-columns: 1fr 1fr 1fr;
            grid-template-rows: 1fr 1fr 1fr;
            gap: 5px;
            max-width: 200px;
            margin: 0 auto;
        }
        .dpad-grid button {
            padding: 1rem;
            font-size: 1.5rem;
            border-radius: 0.5rem;
            transition: transform 0.1s;
        }
        #gameCanvas {
            min-width: 300px;
            min-height: 300px;
            width: 100%;
            height: auto;
        }
        #p1-up { grid-area: up; }
        #p1-down { grid-area: down; }
        #p1-left { grid-area: left; }
        #p1-right { grid-area: right; }
        #p2-up { grid-area: up; }
        #p2-down { grid-area: down; }
        #p2-left { grid-area: left; }
        #p2-right { grid-area: right; }
    </style>
</head>
<body class="bg-gray-900 text-white font-sans p-4 min-h-screen">
    <div class="max-w-4xl mx-auto">
        <h1 class="text-4xl font-bold text-center mb-4 text-emerald-400">üêç Cobrinha Firebase</h1>
        <p class="text-center text-sm mb-2 text-gray-400">Sincroniza√ß√£o em tempo real via Firestore.</p>
        <div class="flex flex-col sm:flex-row justify-between items-center mb-6 bg-gray-800 p-4 rounded-xl shadow-lg">
            <div>
                 <p class="text-lg font-semibold" id="status">Conectando ao Firebase...</p>
                 <p class="text-xs text-gray-500 mt-1">Seu ID de Usu√°rio: <span id="user-id" class="font-mono text-gray-300 text-sm">...</span></p>
                 <p class="text-xs text-gray-500 mt-1" id="player-info">Aguardando atribui√ß√£o de player...</p>
            </div>
            <div class="flex flex-col sm:flex-row gap-4 mt-4 sm:mt-0">
                <button id="reset-btn" class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-6 rounded-lg transition duration-150 shadow-md">
                    Reiniciar Jogo (Se for J1)
                </button>
                <button id="clean-slate-btn" 
                        class="bg-orange-600 hover:bg-orange-700 text-white font-bold py-2 px-6 rounded-lg transition duration-150 shadow-md">
                    FOR√áAR LIMPEZA GERAL
                </button>
            </div>
        </div>
        <div class="flex flex-col lg:flex-row justify-center lg:space-x-8">
            <div class="lg:w-1/4 mb-6 lg:mb-0 space-y-4">
                <div class="bg-gray-800 p-4 rounded-xl shadow-lg">
                    <p id="p1-label" class="text-2xl font-bold text-cyan-400">Jogador 1 (J1)</p>
                    <p class="text-sm text-gray-400 mb-2">ID: <span id="p1-uid" class="font-mono text-xs"></span></p>
                    <p class="text-3xl mt-1"><span id="p1-score">0</span> pts</p>
                </div>
                <div class="bg-gray-800 p-4 rounded-xl shadow-lg">
                    <p id="p2-label" class="text-2xl font-bold text-yellow-400">Jogador 2 (J2)</p>
                    <p class="text-sm text-gray-400 mb-2">ID: <span id="p2-uid" class="font-mono text-xs"></span></p>
                    <p class="text-3xl mt-1"><span id="p2-score">0</span> pts</p>
                </div>
            </div>
            <div class="lg:w-2/4 flex justify-center items-center">
                <canvas id="gameCanvas" class="border-4 border-gray-700 rounded-lg shadow-2xl"></canvas>
            </div>
        </div>
        <h2 class="text-2xl font-bold text-center mt-10 mb-6 text-gray-300">Controles</h2>
        <div class="flex justify-around space-x-4">
            <div class="w-full sm:w-1/2">
                <h3 class="text-xl font-semibold text-center mb-4 text-cyan-400">JOGADOR 1</h3>
                <div class="dpad-grid">
                    <button id="p1-up" class="bg-cyan-600 hover:bg-cyan-700 text-white shadow-md">üîº</button>
                    <button id="p1-down" class="bg-cyan-600 hover:bg-cyan-700 text-white shadow-md">üîΩ</button>
                    <button id="p1-left" class="bg-cyan-600 hover:bg-cyan-700 text-white shadow-md">‚óÄÔ∏è</button>
                    <button id="p1-right" class="bg-cyan-600 hover:bg-cyan-700 text-white shadow-md">‚ñ∂Ô∏è</button>
                    <div class="bg-gray-700 rounded-xl" style="grid-area: center;"></div>
                </div>
            </div>
            <div class="w-full sm:w-1/2">
                <h3 class="text-xl font-semibold text-center mb-4 text-yellow-400">JOGADOR 2</h3>
                <div class="dpad-grid">
                    <button id="p2-up" class="bg-yellow-600 hover:bg-yellow-700 text-white shadow-md">üîº</button>
                    <button id="p2-down" class="bg-yellow-600 hover:bg-yellow-700 text-white shadow-md">üîΩ</button>
                    <button id="p2-left" class="bg-yellow-600 hover:bg-yellow-700 text-white shadow-md">‚óÄÔ∏è</button>
                    <button id="p2-right" class="bg-yellow-600 hover:bg-yellow-700 text-white shadow-md">‚ñ∂Ô∏è</button>
                    <div class="bg-gray-700 rounded-xl" style="grid-area: center;"></div>
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        // Importa√ß√µes diretas do CDN do Firebase
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
        import { getFirestore, doc, setDoc, onSnapshot, runTransaction, getDoc } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";

        // --- CONFIGURA√á√ïES GLOBAIS ---
        const GRID_SIZE = 20;
        const TILE_SIZE = 20;
        const GAME_SPEED_MS = 1500;¬†

        const GAME_ID = 'main_game';
        const GAME_COLLECTION = 'snake_game';

        const P1_COLOR = '#17a2b8';
        const P2_COLOR = '#ffc107';
        const FOOD_COLOR = '#dc3545';
        const BG_COLOR = '#000000';

        let canvas, ctx;
        let db, auth;
        let currentUserId;¬†
        let isAuthReady = false;
        let myPlayerNum = 0;¬†
        let gameState = null;¬†
        let lastTickTime = 0;

        const firebaseConfig = {
            apiKey: "AIzaSyBm43y0sK-01TdZOI8zp9Uf7WM0qkUcobg",
            authDomain: "cobrinha-multiplayer.firebaseapp.com",
            projectId: "cobrinha-multiplayer",
            storageBucket: "cobrinha-multiplayer.firebasestorage.app",
            messagingSenderId: "123381631781",
            appId: "1:123381631781:web:1f21e9e1221f15192668cc"
        };

        // --- L√ìGICA DO JOGO E FIREBASE ---

        function setupFirebase() {
            try {
                const app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);
            } catch (e) {
                console.error("Erro ao inicializar Firebase:", e);
                document.getElementById('status').textContent = "ERRO: Falha ao inicializar Firebase.";
                return;
            }

            let unsubscribe = null;

            onAuthStateChanged(auth, async (user) => {
                if (!user) {
                    // Se n√£o h√° usu√°rio logado, cria um (acontece na primeira visita ou ap√≥s signOut manual)
                    await signInAnonymously(auth);¬†
                    return; 
                }

                currentUserId = auth.currentUser.uid;¬†
                document.getElementById('user-id').textContent = currentUserId;
                isAuthReady = true;

                if (unsubscribe) unsubscribe(); 
                unsubscribe = subscribeToGame(); 
            });
        }

        function getGameDocRef() {
            if (!db) return null;
            return doc(db, GAME_COLLECTION, GAME_ID);¬†
        }

        function getInitialState() {
            return {
                status: 'waiting',
                p1_uid: null,¬†
                p2_uid: null,¬†
                p1: { body: [{x: 5, y: 10}], dx: 1, dy: 0, score: 0, desired_dx: 1, desired_dy: 0 },
                p2: { body: [{x: 15, y: 10}], dx: -1, dy: 0, score: 0, desired_dx: -1, desired_dy: 0 }
            };
        }

        function placeFood(state) {
            let foodPos;
            const occupied = new Set([...state.p1.body.map(s => `${s.x},${s.y}`), ...state.p2.body.map(s => `${s.x},${s.y}`)]);
            do {
                foodPos = {x: Math.floor(Math.random() * GRID_SIZE), y: Math.floor(Math.random() * GRID_SIZE)};
            } while (occupied.has(`${foodPos.x},${foodPos.y}`));
            return foodPos;
        }

        function applyWrapping(head) {
            if (head.x < 0) head.x = GRID_SIZE - 1;
            if (head.x >= GRID_SIZE) head.x = 0;
            if (head.y < 0) head.y = GRID_SIZE - 1;
            if (head.y >= GRID_SIZE) head.y = 0;
        }

        function checkCollisions(state) {
            const p1_head = state.p1.body[0];
            const p2_head = state.p2.body[0];
            const p1_body = state.p1.body;
            const p2_body = state.p2.body;

            const p1_self = p1_body.slice(1).some(s => s.x === p1_head.x && s.y === p1_head.y);
            const p2_self = p2_body.slice(1).some(s => s.x === p2_head.x && s.y === p2_head.y);
            const p1_hits_p2 = p2_body.some(s => s.x === p1_head.x && s.y === p1_head.y);
            const p2_hits_p1 = p1_body.some(s => s.x === p2_head.x && s.y === p2_head.y);

            let p1_dead = p1_self || p1_hits_p2;
            let p2_dead = p2_self || p2_hits_p1;

            if (p1_dead || p2_dead) {
                state.status = 'game_over';
                if (p1_dead && p2_dead) state.winner = "Empate";
                else if (p1_dead) state.winner = "Jogador 2";
                else state.winner = "Jogador 1";
            }
        }

        async function gameTick() {
            if (!gameState || gameState.status !== 'playing' || myPlayerNum !== 1) return;

            try {
                await runTransaction(db, async (transaction) => {
                    const gameDocRef = getGameDocRef();
                    const docSnapshot = await transaction.get(gameDocRef);
                    if (!docSnapshot.exists()) throw new Error("Documento do jogo n√£o existe.");

                    let state = docSnapshot.data();

                    // Aplicar dire√ß√µes desejadas
                    Object.values(state).filter(p => p && p.body).forEach(player => {
                        if (player.dx !== -player.desired_dx || player.dy !== -player.desired_dy || player.body.length === 1) {
                            player.dx = player.desired_dx;
                            player.dy = player.desired_dy;
                        }
                    });

                    // Movimentar cobras
                    const p1_head = { x: state.p1.body[0].x + state.p1.dx, y: state.p1.body[0].y + state.p1.dy };
                    applyWrapping(p1_head);
                    state.p1.body.unshift(p1_head);

                    const p2_head = { x: state.p2.body[0].x + state.p2.dx, y: state.p2.body[0].y + state.p2.dy };
                    applyWrapping(p2_head);
                    state.p2.body.unshift(p2_head);

                    // Verificar comida
                    let ateComida = false;
                    if (state.food && p1_head.x === state.food.x && p1_head.y === state.food.y) { state.p1.score++; ateComida = true; }
                    if (state.food && p2_head.x === state.food.x && p2_head.y === state.food.y) { state.p2.score++; ateComida = true; }

                    if (ateComida) {
                        state.food = placeFood(state);
                    } else {
                        state.p1.body.pop();
                        state.p2.body.pop();
                    }

                    checkCollisions(state);
                    transaction.set(gameDocRef, state);
                });
            } catch (error) {
                console.warn("Transa√ß√£o do Game Tick falhou:", error.message);
            }
        }

        async function setDesiredDirection(dx, dy) {
            if (!gameState || gameState.status !== 'playing' || myPlayerNum === 0) return;

            const playerKey = myPlayerNum === 1 ? 'p1' : 'p2';
            const player = gameState[playerKey];

            if (player.body.length > 1 && player.dx === -dx && player.dy === -dy) {
                return;
            }
            if (player.desired_dx === dx && player.desired_dy === dy) {
                return;
            }

            player.desired_dx = dx;
            player.desired_dy = dy;

            const gameDocRef = getGameDocRef();
            try {
                await setDoc(gameDocRef, { [playerKey]: { desired_dx: dx, desired_dy: dy } }, { merge: true });
            } catch (e) {
                console.error("Erro ao enviar dire√ß√£o:", e);
            }
        }

        // REMOVIDA A FUN√á√ÉO checkAndSignOutIfSpectator para evitar o loop.

        async function updatePlayerAssignments(state) {
            let shouldUpdateFirestore = false;
            let currentStatus = state.status;

            // 1. Tentar atribuir o slot
            // IMPORTANTE: Mantenha a checagem p2_uid !== currentUserId na P1
            if (!state.p1_uid && state.p2_uid !== currentUserId) {
                state.p1_uid = currentUserId; shouldUpdateFirestore = true;
            } 
            // IMPORTANTE: Mantenha a checagem p1_uid !== currentUserId na P2
            else if (!state.p2_uid && state.p1_uid !== currentUserId) {
                state.p2_uid = currentUserId; shouldUpdateFirestore = true;
            }

            // 2. Definir o papel local do usu√°rio
            if (state.p1_uid === currentUserId) myPlayerNum = 1;
            else if (state.p2_uid === currentUserId) myPlayerNum = 2;
            else myPlayerNum = 0; // Espectador

            // 3. Atualizar status do jogo se estiver pronto para jogar
            if (state.p1_uid && state.p2_uid && currentStatus === 'waiting') {
                state.status = 'playing';
                shouldUpdateFirestore = true;
            }

            // 4. Salvar mudan√ßas no Firestore
            if (shouldUpdateFirestore) {
                await setDoc(getGameDocRef(), { p1_uid: state.p1_uid, p2_uid: state.p2_uid, status: state.status }, { merge: true });
            }
            // A corre√ß√£o de "spectator" ao recarregar √© resolvida apenas se o slot for liberado no Firestore.
            // Para ser um jogador, o ID existente PRECISA ser o P1 ou P2 no documento do Firestore.
        }

        function subscribeToGame() {
            if (!isAuthReady || !db) return;
            const gameDocRef = getGameDocRef();

            getDoc(gameDocRef).then(async (docSnap) => {
                if (!docSnap.exists()) {
                    const initial = getInitialState();
                    initial.food = placeFood(initial);
                    await setDoc(gameDocRef, initial);
                }
            }).catch(error => console.error("Erro na leitura inicial do Firestore:", error));

            return onSnapshot(gameDocRef, (doc) => {
                if (doc.exists()) {
                    gameState = doc.data(); 
                    updatePlayerAssignments(gameState);
                    updateUI();
                }
            }, (error) => {
                console.error("Erro no listener do Firestore:", error);
                document.getElementById('status').textContent = "ERRO DE CONEX√ÉO";
            });
        }


        function drawBoard() {
            if (!ctx || !gameState) return;
            ctx.fillStyle = BG_COLOR;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            [gameState.p1, gameState.p2].forEach((player, index) => {
                const color = index === 0 ? P1_COLOR : P2_COLOR;
                player.body.forEach((seg, segIndex) => {
                    ctx.fillStyle = segIndex === 0 ? color : color + 'b0';¬†
                    ctx.fillRect(seg.x * TILE_SIZE, seg.y * TILE_SIZE, TILE_SIZE - 0.5, TILE_SIZE - 0.5);
                });
            });

            if (gameState.food) {
                ctx.fillStyle = FOOD_COLOR;
                ctx.fillRect(gameState.food.x * TILE_SIZE, gameState.food.y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
            }
        }

        function updateUI() {
            if (!gameState) return;
            document.getElementById('p1-score').textContent = gameState.p1.score;
            document.getElementById('p2-score').textContent = gameState.p2.score;
            document.getElementById('p1-uid').textContent = gameState.p1_uid ? gameState.p1_uid.substring(0, 8) + '...' : 'Vazio';
            document.getElementById('p2-uid').textContent = gameState.p2_uid ? gameState.p2_uid.substring(0, 8) + '...' : 'Vazio';

            if (gameState.status === 'waiting') document.getElementById('status').textContent = "Aguardando outro jogador...";
            else if (gameState.status === 'playing') document.getElementById('status').textContent = "EM JOGO";
            else if (gameState.status === 'game_over') document.getElementById('status').textContent = `FIM DE JOGO! Vencedor: ${gameState.winner}`;

            if (myPlayerNum === 1) document.getElementById('player-info').textContent = "Voc√™ √© o Jogador 1 (Host)";
            else if (myPlayerNum === 2) document.getElementById('player-info').textContent = "Voc√™ √© o Jogador 2";
            else document.getElementById('player-info').textContent = "Espectador";
        }

        async function forceCleanSlate() {
            if (!confirm("Tem certeza que deseja limpar o estado do jogo?")) {
                return;
            }

            if (!db || !auth) {
                console.error("Firebase n√£o inicializado.");
                document.getElementById('status').textContent = "ERRO: Firebase n√£o pronto.";
                return;
            }

            const gameDocRef = getGameDocRef();

            try {
                // 1. LIMPA O ESTADO DO JOGO NO FIRESTORE
                const initial = getInitialState();
                initial.food = placeFood(initial);
                // CR√çTICO: N√£o zera p1_uid e p2_uid aqui! Deixa o c√≥digo de atribui√ß√£o fazer isso.
                // Isso garante que o usu√°rio atual (que clicou) ser√° P1 no jogo limpo.

                // For√ßa o ID atual para P1 (o host que est√° limpando)
                initial.p1_uid = currentUserId;
                initial.p2_uid = null;
                initial.status = 'waiting'; 

                await setDoc(gameDocRef, initial);

                // 2. REMOVIDO: N√£o precisa fazer signOut nem reload.
                // O onSnapshot vai pegar o novo estado, ver que p1_uid √© o currentUserId
                // e atribuir myPlayerNum = 1, corrigindo o espectador.

                document.getElementById('status').textContent = "Limpeza Geral Completa. Voc√™ √© o Jogador 1.";

            } catch (e) {
                console.error("Erro durante a limpeza geral:", e);
                document.getElementById('status').textContent = `ERRO NA LIMPEZA: ${e.message}`;
            }
        }

        function setupControls() {
            document.body.addEventListener('click', (e) => {
                if (e.target.tagName !== 'BUTTON') return;
                const controlMap = {
                    'p1-up': {dx: 0, dy: -1, p: 1}, 'p1-down': {dx: 0, dy: 1, p: 1},
                    'p1-left': {dx: -1, dy: 0, p: 1}, 'p1-right': {dx: 1, dy: 0, p: 1},
                    'p2-up': {dx: 0, dy: -1, p: 2}, 'p2-down': {dx: 0, dy: 1, p: 2},
                    'p2-left': {dx: -1, dy: 0, p: 2}, 'p2-right': {dx: 1, dy: 0, p: 2},
                };
                const action = controlMap[e.target.id];
                if (action && myPlayerNum === action.p) setDesiredDirection(action.dx, action.dy);
            });

            document.getElementById('reset-btn').onclick = async () => {
                if (myPlayerNum === 1) {
                    const initial = getInitialState();
                    initial.food = placeFood(initial);
                    initial.p1_uid = gameState.p1_uid;
                    initial.p2_uid = gameState.p2_uid;
                    initial.status = (initial.p1_uid && initial.p2_uid) ? 'playing' : 'waiting';
                    await setDoc(getGameDocRef(), initial);
                } else {
                    document.getElementById('status').textContent = "Apenas o Jogador 1 pode reiniciar.";
                }
            };

            document.getElementById('clean-slate-btn').onclick = forceCleanSlate;

            window.addEventListener('keydown', (e) => {
                const keyMap = { ArrowUp: {dx: 0, dy: -1}, w: {dx: 0, dy: -1}, ArrowDown: {dx: 0, dy: 1}, s: {dx: 0, dy: 1}, ArrowLeft: {dx: -1, dy: 0}, a: {dx: -1, dy: 0}, ArrowRight: {dx: 1, dy: 0}, d: {dx: 1, dy: 0} };
                const move = keyMap[e.key];
                if (move) { e.preventDefault(); setDesiredDirection(move.dx, move.dy); }
            });
        }

        function mainLoop(currentTime) {
            window.requestAnimationFrame(mainLoop);

            if (!gameState) return;

            const secondsSinceLastTick = (currentTime - lastTickTime) / 1000;
            if (secondsSinceLastTick >= GAME_SPEED_MS / 1000 && myPlayerNum === 1 && gameState.status === 'playing') {
                lastTickTime = currentTime;
                gameTick(); 
            }

            drawBoard();
        }

        window.onload = () => {
            canvas = document.getElementById('gameCanvas');
            canvas.width = GRID_SIZE * TILE_SIZE;¬†
            canvas.height = GRID_SIZE * TILE_SIZE;
            ctx = canvas.getContext('2d');

            setupFirebase();
            setupControls();

            window.requestAnimationFrame(mainLoop);
        };
    </script>
</body>
</html>
